"""
config_manager.py - Read/write PicFrame configuration

This module handles reading and writing the user's PicFrame configuration
file (~/.picframe/config). It provides a schema-based approach with
validation and sensible defaults.

Usage:
    from config_manager import read_config, write_config, config_exists

    if config_exists():
        config = read_config()
        print(config.get("RCLONE_REMOTE"))
"""

from pathlib import Path
from typing import Dict, List, Optional


# Default config file location
CONFIG_PATH = Path.home() / ".picframe" / "config"

# Configuration schema - defines all valid config keys
# Each key has: default value, required flag, description
CONFIG_SCHEMA = {
    "RCLONE_REMOTE": {
        "default": "",
        "required": True,
        "description": "Rclone remote and path (e.g., mydrive:photos)",
    },
    "LOCAL_DIR": {
        "default": "",
        "required": True,
        "description": "Local directory for synced photos",
    },
    "APP_ROOT": {
        "default": "/home/pi/picframe_3.0",
        "required": False,
        "description": "PicFrame installation directory",
    },
    "LOG_DIR": {
        "default": "/home/pi/logs",
        "required": False,
        "description": "Log file directory",
    },
    "ALLOWED_HOST": {
        "default": "",
        "required": False,
        "description": "Hostname for safety checks (empty = no check)",
    },
    "ALLOWED_USER": {
        "default": "pi",
        "required": False,
        "description": "Username for safety checks",
    },
    "ACTIVE_SOURCE": {
        "default": "",
        "required": False,
        "description": "Active source ID from frame_sources.conf",
    },
    "FRAME_LIVE_PATH": {
        "default": "/home/pi/Pictures/frame_live",
        "required": False,
        "description": "Symlink path for active photo source",
    },
}


def config_exists() -> bool:
    """Check if the user's config file exists."""
    return CONFIG_PATH.exists()


def get_config_path() -> Path:
    """Return the path to the config file."""
    return CONFIG_PATH


def read_config() -> Dict[str, str]:
    """
    Read and parse the config file.
    
    Returns a dict of key-value pairs. Comments and empty lines are ignored.
    Values are stripped of surrounding quotes.
    
    Returns:
        Dict with config key-value pairs (empty dict if file doesn't exist)
    """
    config: Dict[str, str] = {}
    
    if not CONFIG_PATH.exists():
        return config
    
    try:
        for line in CONFIG_PATH.read_text(encoding="utf-8").splitlines():
            line = line.strip()
            
            # Skip empty lines and comments
            if not line or line.startswith("#"):
                continue
            
            # Parse KEY=value or KEY="value"
            if "=" in line:
                key, val = line.split("=", 1)
                key = key.strip()
                val = val.strip()
                
                # Remove surrounding quotes
                if (val.startswith('"') and val.endswith('"')) or \
                   (val.startswith("'") and val.endswith("'")):
                    val = val[1:-1]
                
                config[key] = val
    except Exception as e:
        # Log error but return what we have
        print(f"Warning: Error reading config file: {e}")
    
    return config


def write_config(data: Dict[str, str]) -> None:
    """
    Write config data to the config file.
    
    Only keys that exist in CONFIG_SCHEMA are written.
    Creates the parent directory if it doesn't exist.
    
    Args:
        data: Dict of config key-value pairs to write
    """
    # Ensure parent directory exists
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    lines = [
        "# ~/.picframe/config - PicFrame Configuration",
        "# Generated by PicFrame Setup",
        "",
    ]
    
    # Write each config value
    for key in CONFIG_SCHEMA.keys():
        val = data.get(key, "")
        if val or CONFIG_SCHEMA[key].get("required"):
            lines.append(f'{key}="{val}"')
    
    CONFIG_PATH.write_text("\n".join(lines) + "\n", encoding="utf-8")


def validate_config(data: Dict[str, str]) -> Dict[str, List[str]]:
    """
    Validate config data against the schema.
    
    Args:
        data: Dict of config key-value pairs to validate
        
    Returns:
        Dict with "errors" and "warnings" lists
    """
    errors: List[str] = []
    warnings: List[str] = []
    
    # Check required fields
    for key, schema in CONFIG_SCHEMA.items():
        if schema.get("required") and not data.get(key, "").strip():
            errors.append(f"{key} is required")
    
    # Validate specific fields
    local_dir = data.get("LOCAL_DIR", "")
    if local_dir and not local_dir.startswith("/"):
        warnings.append("LOCAL_DIR should be an absolute path")
    
    app_root = data.get("APP_ROOT", "")
    if app_root and not app_root.startswith("/"):
        warnings.append("APP_ROOT should be an absolute path")
    
    log_dir = data.get("LOG_DIR", "")
    if log_dir and not log_dir.startswith("/"):
        warnings.append("LOG_DIR should be an absolute path")
    
    rclone_remote = data.get("RCLONE_REMOTE", "")
    if rclone_remote and ":" not in rclone_remote:
        warnings.append("RCLONE_REMOTE should include a colon (e.g., mydrive:photos)")
    
    return {"errors": errors, "warnings": warnings}


def get_config_with_defaults() -> Dict[str, str]:
    """
    Get config values, filling in defaults for missing keys.
    
    Returns:
        Dict with all config keys populated (from file or defaults)
    """
    config = read_config()
    
    for key, schema in CONFIG_SCHEMA.items():
        if key not in config:
            config[key] = schema.get("default", "")
    
    return config


def get_derived_paths(config: Optional[Dict[str, str]] = None) -> Dict[str, Path]:
    """
    Get derived paths based on config values.
    
    Args:
        config: Config dict (reads from file if not provided)
        
    Returns:
        Dict with derived Path objects
    """
    if config is None:
        config = get_config_with_defaults()
    
    app_root = Path(config.get("APP_ROOT") or "/home/pi/picframe_3.0")
    log_dir = Path(config.get("LOG_DIR") or "/home/pi/logs")
    
    return {
        "app_root": app_root,
        "log_dir": log_dir,
        "log_file": log_dir / "frame_sync.log",
        "chk_script": app_root / "ops_tools" / "chk_sync.sh",
        "frame_sources_conf": app_root / "config" / "frame_sources.conf",
        "frame_live": Path(config.get("FRAME_LIVE_PATH") or "/home/pi/Pictures/frame_live"),
    }
